\chapter{Verified Implementation of Inlining}
\label{verified_implementation_of_inlining}
%

This chapter continues the approach described in Section \ref{verified_inlining_at_the_abstract_level:proof_strategy}. The previous chapter defined the syntactic transformation of multi-inlining and showed that any implementation that the relation follows preserves the semantics of the program. This chapter focuses on the implementation of the inlining pass. It describes the transformation function as well as the correctness proof for the implementation. The correctness proof uses the previously introduces relation and the equivalence theorem proved for it.

\section{Implementation}
\label{verified_implementation_of_inlining:implementation}
%

The implementation of the inlining pass follows the same pattern as the multi-inlining relation. It transforms the expression based on the given declarations. The implementation is shown in Figure \ref{fig:inline_function_implementation}.

\begin{figure}
%
\begin{definition}
%
\lstinline{inline} function implementation
%
\begin{holthmenv}
  \HOLthm[def,width=85]{pure_inline_cexp.inline_def}
\end{holthmenv}
%
\end{definition}
%
\caption{\lstinline{inline} function implementation}
\label{fig:inline_function_implementation}
\end{figure}

The function takes:

\begin{enumerate}
  \item \lstinline{m} -- the map of declarations to be inlined.
  \item \lstinline{ns} -- the set of names to avoid when freshening variables.
  \item \lstinline{h} -- the heuristic function that decides whether a declaration is fit to be inlined.
  \item Lastly, the expression to be transformed.
\end{enumerate}

The need for passing the set of names might be surprising since the input to the function is already freshened. The reason for that is that when inlining an expression, it might be valuable to continue inlining inside the inserted definition body. Then the names of the variables in the body might clash with the names in \lstinline{m}. And so the inserted body has to be freshened again. This isn't done in the current implementation of the pass, so it serves as a preparation for future improvements.

The implementation follows quite closely the same pattern as the multi-inlining relation.

\begin{itemize}
  \item \lstinline{Var} case inlines the variable if it is in the map. It also prevents inlining if the expression to be inserted is a lambda abstraction. It is based on the reasoning presented before, there is no benefit from inlining a lambda that is not immediately applied to at least one argument.
  \item \lstinline{App} case handles inlining in the function and the argument. It is slightly more interesting than the corresponding case in the relation. This case also handles inlining lambda abstractions, since if the callee is a variable reference, it is certain at this point that it will be called with at least one argument.
  \item \lstinline{Let} case handles adding more declarations to the map. It is worth noting that the heuristic is checked at the point of adding the declaration to the map, instead of at the point of inlining.
  \item \lstinline{Letrec} case behaves similarly to the \lstinline{Let} case. It only adds non-mutually recursive declarations to the map of inline declarations.
  \item The rest of the cases simply traverse its children and perform inlining deeper. With one exception, \lstinline{NestedCase} is not affected by the transformation. That is because PureCake doesn't support nested cases at present.
\end{itemize}

Using this declaration, a final function was defined that is correctly initialized and hides all the implementation details.

\begin{definition}
%
\lstinline{inline_all} function implementation
%
\begin{holthmenv}
  \HOLthm[def]{pure_inline_cexp.inline_all_def}
\end{holthmenv}
%
\end{definition}

\section{Implementation correctness proof}
\label{verified_implementation_of_inlining:implementation_correctness_proof}
%

Using the multi-inlining relation, a theorem was formulated and proved that shows that the result of the inlining pass satisfies the relation. The statement of the theorem is as follows:

\begin{theorem}
\label{theorem:inline_cexp_list_subst_rel_spec}
%
\begin{holthmenv}
  \HOLthm[width=80]{pure_inline_cexpProof.inline_cexp_list_subst_rel_spec}
\end{holthmenv}
%
\end{theorem}

This theorem is defined for any \lstinline{m, ns, h, e} so it is heuristic-agnostic -- the correctness of the implementation doesn't depend on the heuristic. The assumptions are quite similar to the ones for the equivalence of the relation. The function \lstinline{exp_of} is the link between the two ASTs, it transforms the compiler expressions into meta-theory ones.

\begin{itemize}
  \item \lstinline{memory_inv} is a new addition. The relation used a simple linked list for the declaration storage. The implementation uses a map, to be more efficient. This assumption ensures that the contents of the map and the list are the same.
  \item \lstinline{map_ok} is an artifact of using the specific map implementation.
  \item All the other assumptions give the same guarantees as the ones for the relation-level proof.
\end{itemize}

Finally, the correctness of the full inlining pass was proved by using the above theorem and the equivalence theorem for the relation.

\begin{theorem}
\label{theorem:inline_all_thm}
%
\begin{holthmenv}
  \HOLthm[width=80]{pure_inline_cexpProof.inline_all_thm}
\end{holthmenv}
%
\end{theorem}

Similarly to the relation-level proof, this theorem is defined for any expression that satisfies \lstinline{no_shadowing} and is closed.
