\chapter{Results}
\label{results}
%

This chapter summarises and evaluates the results obtained in this project. It
provides details on the correctness of the pass, as well as the benchmarks
showing its quantitative results.

\section{Correctness Proof}
\label{results:correctness_proof}
%

The correctness proof of inlining is the main result of this project. It can be
separated into the two following theorems:

Firstly, the correctness of the relation that encaptures the semantic
transformation of the inlining pass:

\begin{theorem}
%
\begin{HOLmath}
  \HOLthm[]{pure_inline.list_subst_rel_IMP_exp_eq_specialized}
\end{HOLmath}
%
\end{theorem}

The equivalence proof for the multi-inlining relation is the most important part
of the work. This proof establishes that the multi-inlining relation preserves
the semantics of the original program. And because the multi-inlining relation
encodes the transformation performed by the inlining pass, this theorem proves
the correctness of inlining as a concept.

Secondly, the correctness of the inlining pass implementation:

\begin{theorem}
%
\begin{HOLmath}
  \HOLthm[]{pure_inline_cexpProof.inline_all_thm}
\end{HOLmath}
%
\end{theorem}

This theorem establishes the correctness of the full inlining pass. Like the
relation-level proof, this theorem is defined for any expression that satisfies
no_shadowing and is closed. It's derived from the equivalence theorem for the
relation, thereby providing a thorough proof of the full inlining pass.

Together those two theorems prove that the inlining pass does not alter the semantics
of the input program.

\section{Examples}
\label{results:examles}

To showcase the capabilities of the inlining pass, a few examples are provided.
These examples were transformed using the partially unverified pass. This version
of the pass is unverified since it uses both the specialization
transformation and the freshening function to inline inside the inserted
expressions.

Example 1 -- simple inlining of a constant:

\begin{lstlisting}
let x = 7
in (\m -> x)
\end{lstlisting}

The expression after inlining:

\begin{lstlisting}
let x = 7
in (\m -> 7)
\end{lstlisting}

Example 2 -- transitively inlining let bindings:

\begin{lstlisting}
let f = (\x -> x + 5)
in let y = f 1
in 1 + y
\end{lstlisting}

The expression after inlining:

\begin{lstlisting}
let f = (lam (x) (+ x (int 5)))
in let y = (let x = 1 in 1 + 5)
in 1 + (let x = 1 in 1 + 5)
\end{lstlisting}

A thing of note in the above example is that the inlining pass paved the way for
other optimizations to be applied. In this case, dead code elimination can
remove both bindings for \lstinline{x}. This would allow for the constant value
to be computed at compile time by yet another optimization pass.

Example 3 -- specialization:

\begin{lstlisting}
letrec map = \f -> \lst -> case lst of
  [] -> []
  (x:xs) -> f x : map f xs
in
  let foo = (\x -> x + 1) 
  in map foo
\end{lstlisting}

The expression after inlining:

\begin{lstlisting}
letrec map = \f -> \lst -> case lst of
  [] -> []
  (x:xs) -> f x : map f xs
in
  let foo = (\x -> x + 1) 
  in 
    letrec map = \f -> \lst -> case lst of
      [] -> []
      (x:xs) -> foo x : map foo xs
    in map foo
\end{lstlisting}

Note that the specialization algorithm only specializes in the definition of
\lstinline{map}, without removing the original argument. This optimization of
removing unused bindings can be performed by another optimization pass, similar
to dead code elimination.
